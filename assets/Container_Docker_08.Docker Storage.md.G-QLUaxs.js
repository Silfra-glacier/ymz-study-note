import{_ as i,c as a,o as n,ag as p}from"./chunks/framework.Cizge8DQ.js";const t="/ymz-study-note/assets/Snipaste_2025-01-27_21-49-38.6YXH25sC.png",e="/ymz-study-note/assets/image-20250127221311250.aNxJStbJ.png",g=JSON.parse('{"title":"08.Docker Storage","description":"","frontmatter":{},"headers":[],"relativePath":"Container/Docker/08.Docker Storage.md","filePath":"Container/Docker/08.Docker Storage.md","lastUpdated":1740467903000}'),l={name:"Container/Docker/08.Docker Storage.md"};function k(h,s,d,o,c,r){return n(),a("div",null,s[0]||(s[0]=[p(`<h1 id="_08-docker-storage" tabindex="-1">08.Docker Storage <a class="header-anchor" href="#_08-docker-storage" aria-label="Permalink to &quot;08.Docker Storage&quot;">​</a></h1><h2 id="docker-镜像层" tabindex="-1">Docker 镜像层 <a class="header-anchor" href="#docker-镜像层" aria-label="Permalink to &quot;Docker 镜像层&quot;">​</a></h2><p>在使用 Dockerfile 构建镜像时，每一个 Dockerfile 指令都会创建一个新的 Docker 镜像层，每一层都是基于上一层的构建，只会包含和上一层的新的更改，因此大小不会迅速增加。</p><p>如以下两个 Dockerfile 文件：</p><p><code>dockerfile</code> ：</p><div class="language-dockerfile vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dockerfile</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ubuntu</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 更换 Ubuntu 软件源为阿里云源</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sed -i </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;s|http://archive.ubuntu.com/ubuntu/|http://mirrors.aliyun.com/ubuntu/|g&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /etc/apt/sources.list &amp;&amp; \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sed -i </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;s|http://security.ubuntu.com/ubuntu/|http://mirrors.aliyun.com/ubuntu/|g&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /etc/apt/sources.list &amp;&amp; \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    apt-get update &amp;&amp; \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    apt-get -y install python3 python3-pip</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 配置 pip 使用阿里云镜像</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mkdir -p ~/.pip &amp;&amp; \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    echo </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;[global]</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">index-url = https://mirrors.aliyun.com/pypi/simple/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">[install]</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">trusted-host = mirrors.aliyun.com&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &gt; ~/.pip/pip.conf</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 安装 Flask</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pip install flask --break-system-packages</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 复制源代码到容器中</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">COPY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> . /opt/source-code/</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 设置工作目录</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WORKDIR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /opt/source-code</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 使用 Flask 运行应用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ENTRYPOINT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;flask&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;run&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p><code>dockerfile2</code> ：</p><div class="language-dockerfile vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dockerfile</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ubuntu</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 更换 Ubuntu 软件源为阿里云源</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sed -i </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;s|http://archive.ubuntu.com/ubuntu/|http://mirrors.aliyun.com/ubuntu/|g&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /etc/apt/sources.list &amp;&amp; \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sed -i </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;s|http://security.ubuntu.com/ubuntu/|http://mirrors.aliyun.com/ubuntu/|g&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /etc/apt/sources.list &amp;&amp; \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    apt-get update &amp;&amp; \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    apt-get -y install python3 python3-pip</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 配置 pip 使用阿里云镜像</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mkdir -p ~/.pip &amp;&amp; \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    echo </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;[global]</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">index-url = https://mirrors.aliyun.com/pypi/simple/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">[install]</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">trusted-host = mirrors.aliyun.com&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &gt; ~/.pip/pip.conf</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 安装 Flask</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pip install flask --break-system-packages</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 复制源代码到容器中</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">COPY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> file.txt /opt/source-code/</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 设置工作目录</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WORKDIR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /opt/source-code</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 使用 Flask 运行应用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ENTRYPOINT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;flask&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;run&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>观察文件，两个 Dockerfile 文件中只有 <code>COPY</code> 指令不同，第一个为 <code>COPY . /opt/source-code/</code> ，第二个为 <code>COPY file.txt /opt/source-code/</code> 。</p><blockquote><p>可以在当前目录创建文件，以便保持复制的文件确实不同</p></blockquote><p>先构建 <code>dockerfile</code> 的镜像：</p><div class="language-cmd vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">docker build </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f .\\dockerfile </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">t flask</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app .</span></span></code></pre></div><p>使用 <code>docker images</code> 查看当前镜像的大小，为 549MB ：</p><div class="language-cmd vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PS X:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> docker images</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">flask</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app    latest    12dd24c0bcd1   </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> minutes ago   549MB</span></span></code></pre></div><p>然后构建 <code>dockerfile2</code> 的镜像：</p><div class="language-cmd vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">docker build </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f .\\dockerfile2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">t flask</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app2 .</span></span></code></pre></div><p>再次查看镜像大小：</p><div class="language-cmd vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PS X:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> docker images</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">flask</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app2   latest    447a485a4d4f   </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> seconds ago   549MB</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">flask</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app    latest    12dd24c0bcd1   </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> minutes ago   549MB</span></span></code></pre></div><p>发现两个镜像大小相同，但实际上两个镜像一共占用宿主机约为 549MB 大小，而不是两个镜像大小之和 549 + 549 = 1098MB 。原因是两个 Dockerfile 文件除了 <code>COPY</code> 指令前的所有指令全部相同，因此之前的每个所有指令都会创建一个新层，而这些层会被创建第二个镜像时复用，而不是创建新的层，因此他们共享同一个镜像文件（共享的是底层的文件）。</p><p>只有当所有共享的镜像文件都被删除时，原本的层才会被删除。当删除第一个构建的镜像 <code>flask-app</code> 时，镜像 <code>flask-app2</code> 仍可使用。</p><h2 id="容器层" tabindex="-1">容器层 <a class="header-anchor" href="#容器层" aria-label="Permalink to &quot;容器层&quot;">​</a></h2><p>容器层是<strong>可读可写</strong>的，镜像层是<strong>只读</strong>的：</p><p><img src="`+t+'" alt="Snipaste_2025-01-27_21-49-38"></p><p>所以镜像中的文件不可被修改。</p><p>使用镜像创建容器后，容器内的文件会拷贝一份到容器内，可在容器内修改这些文件，如上图中的 <code>app.py</code> 文件；可在容器内创建新文件，如上图中的 <code>temp.txt</code> 文件。</p><h2 id="卷映射" tabindex="-1">卷映射 <a class="header-anchor" href="#卷映射" aria-label="Permalink to &quot;卷映射&quot;">​</a></h2><p>容器内创建的数据不会被持久化保存，若想要持久化保存，则将数据保存到宿主机上，建立容器内和宿主机目录（或<strong>卷</strong>）之间的映射，使得容器内产生的文件到容器内的目标目录后，相当于保存到了宿主机上的指定目录（卷）。</p><p>在 Linux 系统上，卷的默认保存位置在 <code>/var/lib/docker/volumes</code> 中，但也可以显式指定映射的目标目录。使用 <code>-v</code> 选项指定映射：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -v</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> data_volumes:/var/lib/mysql</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mysql</span></span></code></pre></div><p><img src="'+e+'" alt="image-20250127221311250"></p><p>这里给出了宿主机上的相对路径，使用了 <code>volume</code> 模式。</p><p>相当于将宿主机上 <code>/var/lib/docker/volumes/data_volumes</code> 目录和容器内 <code>/var/lib/mysql</code> 目录建立映射，此后在容器内产生到 <code>/var/lib/mysql</code> 目录下的文件都将被保存到宿主机的 <code>/var/lib/docker/volumes/data_volumes</code> <strong>卷</strong>内，实现持久化。</p><blockquote><p><code>data_volumes</code> 是 Docker 内部管理的卷名称，而不是宿主机上的目录，默认存储在 <code>/var/lib/docker/volumes/</code> 目录下。</p><p>在 <code>volumes</code> 目录下会存在一个名为 <code>data_volumes</code> 的文件夹，下面会有一个 <code>_data</code> 的文件夹，产生的文件将存放此文件夹内， <code>data_volumes</code> 理解为一个卷，如果没有该卷，Docker 会自动创建它。</p></blockquote><p>也可以显式指定宿主机上的其他目录，使用绝对路径，此时使用的是 <code>bind</code> 模式：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -v</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /dara/mysql:/var/lb/mysql</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mysql</span></span></code></pre></div><blockquote><p>如果使用 <code>bind</code> 模式，则映射到宿主机上的为目录而不是卷。</p></blockquote><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p></p><p>注意， <code>-v</code> 选项是一个<strong>过时</strong>的选项，现在要建立卷映射，一般使用 <code>–mount</code> 选项。</p></div><p><code>--mount</code> 选项：</p><p>使用 <code>--mount</code> 选项建立映射的指令格式如下：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --mount</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> type=bind,source=/data/mysql,target=/var/lib/mysql</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mysql</span></span></code></pre></div><ul><li>指定使用 <code>bind</code> 模式，后面给出绝对路径（ <code>mount</code> 强制要求给出绑定的模式， <code>bind</code> 或者 <code>volume</code> ）</li><li><code>source</code> 给出宿主机绝对路径</li><li><code>target</code> 给出容器内路径</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><p><code>--mount</code> 的语法更严格，比如 <code>source</code> 必须显式为绝对路径。</p></div><blockquote><ul><li>使用 <code>-v</code> 选项时，Docker 会自动根据路径判断是创建一个 <strong>卷（volume）</strong> 还是 <strong>绑定挂载（bind mount）</strong>。</li><li><strong>卷（Volume）</strong> 存储在 Docker 管理的 <code>/var/lib/docker/volumes/</code> 目录下，并且在卷内部有一个 <code>_data</code> 子目录来存储实际数据。</li><li><strong>绑定挂载（Bind Mount）</strong> 使用宿主机上的<strong>路径作为挂载点</strong>，数据直接存储在宿主机的目录中。</li><li>推荐使用 <strong><code>--mount</code></strong> 选项，它提供了更清晰和严格的语法。</li></ul></blockquote>',43)]))}const u=i(l,[["render",k]]);export{g as __pageData,u as default};
